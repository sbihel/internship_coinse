<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>Week  3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="Bibliography"><h1 id="Bibliography">Bibliography</h1></div>
<ul>
<li>
TODO Evaluating CAVM: A New Search-Based Test Data Generation Tool for C (long 1st-submission version)

</ul>

<div id="Bibliography-AVM"><h2 id="AVM">AVM</h2></div>
<ul>
<li>
<a href="http:&#47;&#47;eprints.whiterose.ac.uk&#47;104204&#47;1&#47;c43.pdf">mcminn2016avmf</a> AVMf: An open-source framework and implementation of the alternating variable method

<ul>
<li>
Implementation of AVM with all sorts of improvement

<li>
Advantage is that it is general (e.g. so no refactoring needed)

<li>
Good history of AVM

</ul>
</ul>

<div id="Bibliography-SBSE"><h2 id="SBSE">SBSE</h2></div>
<ul>
<li>
REDO <a href="http:&#47;&#47;onlinelibrary.wiley.com&#47;doi&#47;10.1002&#47;stvr.294&#47;epdf">mcminn2004search</a> Search-based Software Test Data Generation: A Survey

<ul>
<li>
Test Data Generation Survey.

<li>
Good overview of Metaheuristic Search Techniques (Section 2) and Structural (White-Box) Testing (Section 3)

</ul>
<li>
TODO <a href="http:&#47;&#47;mcminn.io&#47;publications&#47;tr1.pdf">mcminn2007iguana</a> IGUANA: Input Generation Using Automated Novel Algorithms. A Plug and Play Research Tool

</ul>

<div id="Bibliography-Dynamically-Typed Languages"><h2 id="Dynamically-Typed Languages">Dynamically-Typed Languages</h2></div>
<ul>
<li>
<a href="https:&#47;&#47;www.researchgate.net&#47;profile&#47;David_Ungar2&#47;publication&#47;247925189_Interactive_type_analysis_and_extended_message_splitting_optimizing_dynamically-typed_object-oriented_programs&#47;links&#47;540f8fbd0cf2f2b29a3de0a4.pdf">chambers1991iterative</a> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs

<ul>
<li>
Type analysis (haven't actually read)

</ul>
<li>
<a href="http:&#47;&#47;www.torkar.se&#47;resources&#47;mairhofer_2011_sbst_dynlang_camera_ready_usletter_embedded_fonts_110520.pdf">mairhofer2011search</a> <span id="Bibliography-Dynamically-Typed Languages-Search-based Software Testing and Test Data Generation for a Dynamic Programming Language"></span><strong id="Search-based Software Testing and Test Data Generation for a Dynamic Programming Language">Search-based Software Testing and Test Data Generation for a Dynamic Programming Language</strong>

<ul>
<li>
ðŸ˜¿

<li>
Source code not available, random testing to compare to made themselves...

<li>
Excludes the testing of code that makes use of runtime modification, focuses on dynamic typing

<li>
Structural testing, evolutionary search

<li>
Input data generation

<ul>
<li>
GA to search appropriate input values, starting with random population

</ul>
</ul>
<li>
<a href="https:&#47;&#47;github.com&#47;IgnoredAmbience&#47;splats">splats</a> <span id="Bibliography-Dynamically-Typed Languages-SpLATS: Lazy Automated Testing System (for Ruby)"></span><strong id="SpLATS: Lazy Automated Testing System (for Ruby)">SpLATS: Lazy Automated Testing System (for Ruby)</strong>

<ul>
<li>
Students software developement project

<li>
Regression testing

<li>
Uses Mock objects

<ul>
<li>
"It can respond to all methods; return another Mock object if output is required; and can collect information
          about all the required methods the class it is mocking needs to implement."

<li>
"The chosen methodâ€™s signature is examined and all possible sets of arguments are determined, taking into
          consideration required and optional parameters."

<li>
Each argument and most outputs is either nil or Mock, sometimes outputs are primitive types.

<li>
"SpLATS therefore includes the entire execution tree of Mock objects."

</ul>
<li>
Executes line by line to determine acceptable types

<li>
Only interesting parts are 4.3 &amp; 6.1.1

</ul>
<li>
<a href="https:&#47;&#47;github.com&#47;evandrix&#47;Splat&#47;blob&#47;master&#47;report&#47;final.pdf">Splat</a> <span id="Bibliography-Dynamically-Typed Languages-SPLAT: Simple Python Lazy Automated Tester"></span><strong id="SPLAT: Simple Python Lazy Automated Tester">SPLAT: Simple Python Lazy Automated Tester</strong>

<ul>
<li>
Student Final Year Project

<li>
Pythoscope: only produces a very rudimentary unit snippet; Pytestsgenerator: about the same

<li>
Useful to tackle Python later

<li>
Uses bytecode

<li>
Detailed unit test generation:

<ol>
<li>
All <code>None</code>s

<li>
All <code>None</code>s with structure

<li>
<code>MetaParams</code>, with structure and defaults

<li>
Lazy instantiation

<li>
Argument list to <code>UnitTestObject</code>

<li>
Recursive function tester

</ol>
<li>
On the infinite range of values: "one possible solution is to extract constants from the Python bytecode as
      candidate values for testing first, then try the minimum, midway, and maximum range of the data type [...] then
      randomly generate test data with feedback later"

<li>
Regular expression on error messages (e.g. to deduce type if <code>TypeError</code>)

</ul>
<li>
TODO <a href="http:&#47;&#47;www.hpi.uni-potsdam.de&#47;hirschfeld&#47;publications&#47;media&#47;HauptPerscheidHirschfeld_2011_TypeHarvestingAPracticalApproachToObtainingTypingInformationInDynamicProgrammingLanguages_AcmDL.pdf">haupt2011type</a> Type Harvesting A Practical Approach to Obtaining Typing Information in Dynamic Programming Languages

<ul>
<li>
"exploiting unit tests to automatically obtain type information for a code base"

</ul>
<li>
TODO <a href="http:&#47;&#47;cseweb.ucsd.edu&#47;~rchugh&#47;research&#47;popl12-nested.pdf">chugh2012nested</a> (<a href="https:&#47;&#47;arxiv.org&#47;pdf&#47;1112.4106.pdf">chugh2012dependent</a>) Nested Refinements: A Logic for Duck Typing

<ul>
<li>
"System D coordinates SMT-based logical implication and syntactic subtyping to automatically typecheck"

</ul>
<li>
<a href="http:&#47;&#47;lively-kernel.org&#47;repository&#47;webwerkstatt2011&#47;draft&#47;NewWorld&#47;SteinertHauptKrahnHirschfeld_2010_ContinuousSelectiveTesting_SpringerLNBIP.pdf">steinert2010continuous</a> Continuous Selective Testing

<ul>
<li>
Regression testing that can handle dynamically-typed languages

</ul>
</ul>

<div id="Bibliography-Object-Oriented Languages &#47; Complex Structures"><h2 id="Object-Oriented Languages &#47; Complex Structures">Object-Oriented Languages / Complex Structures</h2></div>
<ul>
<li>
<a href="http:&#47;&#47;citeseerx.ist.psu.edu&#47;viewdoc&#47;download?doi=10.1.1.3.1224&amp;rep=rep1&amp;type=pdf">hayes1994testing</a> Testing of Object-Oriented Programming Systems (OOPS): A Fault-Based Approach

<ul>
<li>
"Fault-based testing refers to the collection of information on whether classes of software faults (or defects)
      exist in a program"

<li>
Tables are missing ã… .ã…  (one lists errors)

</ul>
</ul>

<div id="Bibliography-Random Testing"><h2 id="Random Testing">Random Testing</h2></div>
<ul>
<li>
<a href="http:&#47;&#47;etheses.whiterose.ac.uk&#47;7981&#47;1&#47;ociamthesismain.pdf">ahmad2014new</a> New Strategies for Automated Random Testing (Thesis)

<ul>
<li>
Presentation of different kinds of testing and tools

<li>
The rest is about identifying fault

</ul>
</ul>

<div id="Bibliography-Mutation Testing"><h2 id="Mutation Testing">Mutation Testing</h2></div>
<ul>
<li>
<a href="http:&#47;&#47;dl.acm.org&#47;citation.cfm?id=2025181">gligoric2011smutant</a> SMutant: A Tool for Type-Sensitive Mutation Testing in a Dynamic Language

<ul>
<li>
"In addition to literal replacement, SMutant supports many mutation operators that are commonly seen in tools for
      statically typed languages, such as operator replacement."

<li>
"Instead of applying mutations statically, SMutant postpones mutating until execution and applies mutations
      dynamically, when the types are available."

</ul>
<li>
<a href="http:&#47;&#47;www2.hull.ac.uk&#47;science&#47;pdf&#47;scriptMutation.pdf">bottaci2010type</a> Type Sensitive Application of Mutation Operators for Dynamically Typed Programs

<ul>
<li>
"definition of mutants is performed at run-time when type information is available"

</ul>
</ul>


<div id="Journal"><h1 id="Journal">Journal</h1></div>
<div id="Journal-Things Done"><h2 id="Things Done">Things Done</h2></div>
<ul>
<li>
Related work

<li>
Dynamic Programming Language Testing

<ul>
<li>
OO tightly involved

<ul>
<li>
if it's not OO then error messages should be more clear about the type(?)

<li>
and if we're not focusing on method testing then it's always the same thing, how to fill structures? (objects,
          lists, ...)

<li>
objects bring one more difficulty, they have a state that changes over time during execution

</ul>
<li>
Deduce type from method calls?

<ul>
<li>
Have a list of potential types?

<li>
Mock objects?

<li>
Laziness?

</ul>
<li>
Splat falls into the feedback testing while RuTeG is in systematic (optimization) testing (?)

<li>
Every type has an infinite search space

</ul>
<li>
Meeting Notes (2017-05-31)

<ul>
<li>
Focus on primitives types only (not on classes)

<li>
Random testing with every types

<li>
Instrument Python code

<li>
AVM to find correct type

</ul>
<li>
Instrument Python

<ul>
<li>
<a href="https:&#47;&#47;docs.python.org&#47;3&#47;library&#47;ast.html">https://docs.python.org/3/library/ast.html</a>

<li>
<a href="https:&#47;&#47;greentreesnakes.readthedocs.io&#47;en&#47;latest&#47;">https://greentreesnakes.readthedocs.io/en/latest/</a>

<li>
<a href="http:&#47;&#47;www.dalkescientific.com&#47;writings&#47;diary&#47;archive&#47;2010&#47;02&#47;22&#47;instrumenting_the_ast.html">http://www.dalkescientific.com/writings/diary/archive/2010/02/22/instrumenting_the_ast.html</a>

<li>
<a href="http:&#47;&#47;adamrehn.com&#47;articles&#47;ast-instrumentation-examples-by-language&#47;">http://adamrehn.com/articles/ast-instrumentation-examples-by-language/</a>

</ul>
<li>
Dealing with <code>if</code> conditions

<ul>
<li>
Instead of looking at Expr of <code>if</code>, should I just modify every comparison and <code>or</code> and <code>and</code>?

<li>
You can have all sorts of things in <code>if</code>, like a <code>list</code> to test if it's empty of not

<ul>
<li>
Should care about that later (see difflib)

</ul>
</ul>
<li>
Seminar (ì„±ë¯¼)

<ul>
<li>
Managing Performance vs Accuracy Trade-offs With Loop Performance

<li>
Perform just a subset of loops' iterations

</ul>
</ul>

<div id="Journal-Blocking Points"><h2 id="Blocking Points">Blocking Points</h2></div>
<ul>
<li>
The queue used by Process, the program puts in it its traces?

<li>
Returns in switch cases in function calls

<li>
Add child to parent

<ul>
<li>
2 passes, first one to print additional if, second is the original

<li>
TreeTransform -&gt; requires to use SemaConsumer instead of ASTConsumer (<a href="https:&#47;&#47;stackoverflow.com&#47;questions&#47;30451485&#47;how-to-clone-or-create-an-ast-stmt-node-of-clang">SO</a>)

</ul>
</ul>

<div id="Journal-Planned work"><h2 id="Planned work">Planned work</h2></div>
<ul>
<li class="done0">
Think about what work to focus on (dynamically typed languages?)

<li class="done4">
Understand CAVM

<li class="done0">
Read about testing Dynamically Typed languages

<ul>
<li>
Focus on random testing maybe

</ul>
<li class="done0">
Have a cavm run working for <code>switch</code>

<li class="done1">
Instrument Python code

<ul>
<li class="done0">
Refactor <code>main.py</code> to be able to handle different languages

<li class="done2">
Instrument code

<ul>
<li class="done2">
Modify code

<ul>
<li class="done4">
Basic comparators handled: <del>Eq</del> | <del>NotEq</del> | <del>Lt</del> | <del>ltE</del> | <del>Gt</del> | <del>GtE</del>

<li class="done0">
Other comparators handled: Is | IsNot | In | NotIn

<li class="done4">
Use methods instead <code>l_and</code> e.g.

<li class="done2">
Branching handled

<ul>
<li class="done4">
<code>if</code>

<ul>
<li class="done4">
<code>if</code>

<li class="done4">
<code>else</code>

</ul>
<li class="done2">
<code>while</code>

<ul>
<li class="done4">
<code>while</code>

<li class="done0">
<code>else</code>

</ul>
<li class="done0">
<code>for</code>

<ul>
<li class="done0">
<code>for</code>

<li class="done0">
<code>else</code>

<li class="done0">
<code>AsyncFor</code>

</ul>
</ul>
</ul>
<li class="done4">
Write <code>branch_distance</code> functions

<li class="done2">
Generate the dependence map

<ul>
<li class="done4">
<code>stmtid</code> generation

<li class="done4">
dependence assignment

<li class="done0">
Make the <code>ControlDependency cfg</code> more global as in the c version

</ul>
</ul>
</ul>
<li class="done0">
AVM to find correct type of python function

<ul>
<li class="done0">
Make it possible for cavm to execute the python function

</ul>
<li class="done4">
Do a seperate project instead of branch for python instrumentation

<ul>
<li class="done4">
Make own project and merge old branch from cavm -&gt; did a patch instead

<li class="done4">
Add ì¤€íœ˜ as collaborator

</ul>
</ul>

</body>
</html>
